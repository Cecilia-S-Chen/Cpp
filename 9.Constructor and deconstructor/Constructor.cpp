#include <iostream>
#include <string>
using namespace std;
/*
 * 构造函数：
 * 1、目的：初始化类对象的成员变量
 * 2、表达式：
 *  （1）构造函数与类名相同
 *  （2）构造函数没有返回类型
 *  （3）构造函数可以overload
 *  （4）构造函数不能被声明成const！！！因为只有对象被构造完，才能获得const属性
 * 3、默认构造函数：
 *      （1）没有overload构造函数时，系统自动生成合成的默认构造函数，使用合成的默认构造函数初始化对象
 *      （2）一旦程序员定义了构造函数，合成的默认构造函数将不存在！！所以程序员应该重新定义一个默认构造函数
 */
class Sale_item {
    Sale_item() = default;
    /*
     * 构造函数初始化列表：
     *  1、定义：为新创建对象的部分或全部数据成员赋值
     *  2、作用：不使用构造函数初始化列表，数据成员会被先默认初始化，当构造函数体内对该成员赋值时，再覆盖之前的默认初始化。（区别构造函数体内赋值与列表初始化！）
     *          使用构造函数初始化列表，数据成员直接由列表传入的值初始化，未被初始化的才会采用默认初始化。数据成员只初始化一次！
     *
     *  3、tips：
     *      （1）为部分数据成员赋值，其他的成员默认初始化
     *  4、必须列表初始化的情况
     *       (1) 如果成员是 const 或者 引用 的话，必须通过初始值列表将其初始化
     *      （2） 如果类 没有默认构造函数 的话，成员变量不会默认初始化，必须通过列表初始化！
     *  5、构造函数初始化顺序：
     *      1、成员变量初始化顺序，和类中的定义顺序一致，和初始化列表中的顺序不一定一致！！！
     *      2、最好使用入参初始化成员变量，尽量避免使用成员变量初始化其他成员变量
     *          如果成员变量A依据成员变量B初始化，则A定义在B的后面，否则会出现 用未初始化的B定义A的情况！
     *   6、构造函数默认实参：
     *      1、默认实参：在函数定义时给入参赋的值为默认实参，在调用该函数时，可以省略该入参，相当于调用默认实参
     *      2、如果构造函数给所有入参都赋值，则该构造函数等同于默认构造函数 -> 默认构造函数是没有入参/入参都赋值的构造函数！！！
     *
     */
    Sale_item(string &s) : bookNo(s);
    Sale_item(string &s, int n, double p) : bookNo(s), units_sold(n), revenue(p*n) {};


    /*
     * 委托构造函数：
     *  1、定义：使用该类的其他构造函数，执行自身的初始化过程
     *  2、表达式：
     *      委托构造函数类名（参数列表参数必须少于被委托的构造函数参数列表参数！）：初始化列表为被委托的构造函数声明
     *      函数体：
     *          （1）如果该委托构造函数只是初始化成员变量，则函数体为空
     *          （2）如果该委托构造函数有独特职能，体现在body中，程序会 执行完被委托构造函数后（初始化列表+body） 再执行委托构造函数body
     *  3、tips：
     *      间接委托：委托构造函数A可以把初始化委托给委托构造函数B，委托构造函数B可以委托给一般构造函数
     */
    Sale_item() : Sale_item(" ", 0, 0) {} // 默认构造函数委托给了三参数构造函数
    Sale_item(string s) : Sale_item(s, 0, 0) {} // 该委托构造函数委托给三参数构造函数
    Sale_item(istream &is) : Sale_item() //程序执行完被委托的默认构造函数后，执行该委托函数body
    {
        cout << is << endl;
    }


    /*
     * 4、构造函数初始化：
     *  （1）使用列表初始化
     *  （2）使用"="初始化
     *  （3）使用"{}"初始化！
     */
    int bookNo = 0;
    int units_sold = 0;
    vector<string> soldBookList {""}; //用列表初始化vector
};


class ConstRef {
public:
    ConstRef(int ii);

private:
    int i;
    const int ci;
    int &ri;
};

ConstRef::ConstRef(int ii)
{/*
 * 因为定义了构造函数，默认构造函数失效，成员变量不能通过默认构造函数赋初值
 */
    i = ii; // 正确
    ci = ii; // 错误：不能给const赋值，必须要通过列表初始化
    ri = ii; // 错误：ri作为引用没有绑定对象，所以不能赋值
}



class 